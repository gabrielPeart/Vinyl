import cocoa.*;
import cocoa.appkit.*;
import sqlite.*;
import maybe.*;
import Vinyl.library.*;
import Vinyl.controllers.main.*;
import Vinyl.controls.deletingtableview.*;
import Vinyl.formatting.*;
import Vinyl.qtplayer.*;
import Vinyl.util.sqlitelazysequence.*;


//
// data source for library outline view
//

overload selector(static #"initWithLibrary:") = Id, Pointer[Library];
overload selector(static #"insertPlaylistWithName:parentItem:")
    = Id, NSString, Id;
overload selector(static #"insertPlaylistFolderWithName:")
    = Id, NSString;
overload selector(static #"libraryView:selectFilter:")
    = Id, NSOutlineView, Pointer[LibraryFilter];
overload selector(static #"selectedFilterForLibraryView:playlistView:")
    = Pointer[LibraryFilter], NSOutlineView, NSTableView;

libraryDataSourceItemCount(self: LibraryDataSource)
    = NSInteger(
        1 // Library
        + self^.folders.count() // folders
        + self^.playlists.count() // toplevel playlists
    );

record LibraryDataSource = newClass(NSObject,
    InstanceVars(
        [#library, Pointer[Library]],
        [#folders, Retained[NSMutableArray]],
        [#playlists, Retained[NSMutableArray]],
        [#libraryFilter, LibraryFilter],
    ),
    ClassMethods(
    ),
    InstanceMethods(
        [#"initWithLibrary:", (self, library) => initObjectWith(self, #"init", self => {
            self^.library = library;
            self^.folders = NSMutableArray.array();
            self^.playlists = NSMutableArray.array();
            self^.libraryFilter = LibraryFilter();
            refreshLibraryDataSource(self);
            return self;
        })],
        DeallocInstanceMethod(),
        [#"libraryView:selectFilter:", (self, outlineView, libraryFilter) => {
            var row = NSUInteger(0);
            matchByType(libraryFilter^,
                PlaylistFilter, v -> {
                    for (folder in self^.folders)
                        for (playlist in folder["playlists"])
                            if (playlist["id"] == v.id) {
                                outlineView.expandItem(folder);
                                row = outlineView.rowForItem(playlist);
                                return;
                            }
                    for (playlist in self^.playlists)
                        if (playlist["id"] == v.id) {
                            row = outlineView.rowForItem(playlist);
                            return;
                        }
                },
                PlaylistFolderFilter, v -> {
                    for (folder in self^.folders)
                        if (folder["id"] == v.id) {
                            row = outlineView.rowForItem(folder);
                            return;
                        }
                },
                SortedFilter, v -> { row = 0; }
            );
            outlineView.selectRowIndexes_byExtendingSelection(
                NSIndexSet.indexSetWithIndex(NSUInteger(row)),
                false
            );
        }],
        [#"selectedFilterForLibraryView:playlistView:", (self, outlineView, playlistView) => {
            var item = outlineView.itemAtRow(outlineView.selectedRow());

            self^.libraryFilter = if (itemIsFolder?(item))
                    LibraryFilter(PlaylistFolderFilter(NSInteger(item["id"])))
                else if (itemIsPlaylist?(item))
                    LibraryFilter(PlaylistFilter(NSInteger(item["id"])))
                else
                    LibraryFilter(SortedFilter(playlistView.sortDescriptors()));
            return &self^.libraryFilter;
        }],
        [#"outlineView:numberOfChildrenOfItem:", (self, outlineView, item) =>
            if (nil?(item))
                libraryDataSourceItemCount(self)
            else if (itemIsFolder?(item))
                NSInteger(item["playlists"].count()) // playlist folder
            else
                NSInteger(0) // library or playlist, no children
        ],
        [#"outlineView:isItemExpandable:", (self, outlineView, item) => itemIsFolder?(item)],
        [#"outlineView:child:ofItem:", (self, outlineView, index, item) => {
            if (nil?(item)) {
                if (index == 0)
                    return Id(#"Library");
                else {
                    var numFolders = self^.folders.count();
                    if (index - 1 < numFolders)
                        return self^.folders[index - 1];
                    else
                        return self^.playlists[index - numFolders - 1];
                }
            } else
                return item["playlists"][index];
        }],
        [#"outlineView:objectValueForTableColumn:byItem:", (self, outlineView, column, item) => {
            if (item.isKindOfClass(NSString))
                return item;
            else
                return item["name"];
        }],
        [#"outlineView:persistentObjectForItem:", (self, outlineView, item) => {
            if (itemIsFolder?(item))
                return item["id"];
            else
                return nil(Id);
        }],
        [#"outlineView:itemForPersistentObject:", (self, outlineView, object) => {
            println(object);
            if (object.isKindOfClass(NSNumber)) {
                for (folder in self^.folders)
                    if (folder["id"] == object)
                        return folder;
            }
            return nil(Id);
        }],
        [#"outlineView:setObjectValue:forTableColumn:byItem:", (self, outlineView, value, column, item) => {
            if (item.isKindOfClass(NSString))
                return;
            else if (value.description().length() == 0)
                return;
            else {
                item.setObject_forKey(value.description(), "name");
                if (itemIsFolder?(item))
                    updateLibraryFolderName(self^.library^, NSInteger(item["id"]), String(value));
                else
                    updateLibraryPlaylistName(self^.library^, NSInteger(item["id"]), String(value));
            }
        }],
        [#"outlineView:deleteItem:", (self, outlineView, item) => {
            if (item.isKindOfClass(NSString))
                return;
            var oldRow = outlineView.rowForItem(item);
            var parentItem = outlineView.parentForItem(item);

            if (itemIsFolder?(item)) {
                releaseDatabaseLocks();
                deleteLibraryFolder(self^.library^, NSInteger(item["id"]));
                self^.folders.removeObject(item);
            } else {
                releaseDatabaseLocks();
                deleteLibraryPlaylist(self^.library^, NSInteger(item["id"]));
                self^.playlists.removeObject(item);
                for (folder in self^.folders)
                    folder["playlists"].removeObject(item);
            }

            outlineView.reloadData();
            if (oldRow < outlineView.numberOfRows())
                outlineView.selectRowIndexes_byExtendingSelection(
                    NSIndexSet.indexSetWithIndex(NSUInteger(oldRow)),
                    false
                );
            else
                outlineView.selectRowIndexes_byExtendingSelection(
                    NSIndexSet.indexSetWithIndex(NSUInteger(outlineView.numberOfRows() - 1)),
                    false
                );
        }],

        [#"outlineView:writeItems:toPasteboard:", (self, outlineView, items, pasteboard) => {
            if (items.count() != 1)
                return false;
            var item = items[0];
            if (not itemIsPlaylist?(item))
                return false;

            outlineView.setDraggingSourceOperationMask_forLocal(
                NSUInteger(bitor(NSDragOperationMove, NSDragOperationDelete)),
                false,
            );

            pasteboard.declareTypes_owner(
                makeNSArray(PlaylistIdsPboardType),
                self
            );
            pasteboard.setPropertyList_forType(makeNSArray(item["id"]), PlaylistIdsPboardType);

            return true;
        }],

        [#"outlineView:validateDrop:proposedItem:proposedChildIndex:", (self, outlineView, info, item, index) => {
            if (item.isKindOfClass(NSString))
                return NSDragOperation(NSDragOperationNone);

            var pasteboard = info.draggingPasteboard();
            var pasteboardType = pasteboard.availableTypeFromArray(
                makeNSArray(TrackIdsPboardType, PlaylistIdsPboardType)
            );
            if (nil?(pasteboardType))
                return NSDragOperation(NSDragOperationNone);

            if (nil?(item))
                outlineView.setDropItem_dropChildIndex(
                    nil(),
                    NSInteger(-1)
                );
            else if (itemIsFolder?(item))
                outlineView.setDropItem_dropChildIndex(
                    item,
                    NSInteger(item["playlists"].count())
                );
            else if (itemIsPlaylist?(item) and pasteboardType == PlaylistIdsPboardType)
                return NSDragOperation(NSDragOperationNone);

            return NSDragOperation(NSDragOperationCopy);
        }],

        [#"outlineView:acceptDrop:item:childIndex:", (self, outlineView, info, item, index) => {
            if (item.isKindOfClass(NSString))
                return false;

            var pasteboard = info.draggingPasteboard();
            var pasteboardType = pasteboard.availableTypeFromArray(
                makeNSArray(TrackIdsPboardType, PlaylistIdsPboardType)
            );
            if (nil?(pasteboardType))
                return false;

            var playlistItem = nil();
            var newPlaylist? = false;
            if (pasteboardType == TrackIdsPboardType) {
                if (itemIsPlaylist?(item))
                    playlistItem = item;
                else {
                    playlistItem = self.insertPlaylistWithName_parentItem(
                        #"New Playlist", // XXX derive playlist name from track attributes
                        item
                    );
                    newPlaylist? = true;
                }

                var trackIds = NSArray(pasteboard.propertyListForType(pasteboardType));
                releaseDatabaseLocks();
                insertLibraryPlaylistTracks(self^.library^, NSInteger(playlistItem["id"]), mapped(NSInteger, trackIds));
            } else if (pasteboardType == PlaylistIdsPboardType) {
                var playlistId = NSInteger(pasteboard.propertyListForType(pasteboardType)[0]);
                var parentFolderId = if (itemIsFolder?(item))
                    Maybe(NSInteger(item["id"]))
                else
                    nothing(NSInteger);

                for (folder in self^.folders)
                    for (playlist in folder["playlists"])
                        if (playlist["id"] == playlistId) {
                            if (parentFolderId == Maybe(NSInteger(folder["id"])))
                                return false;
                            playlistItem = playlist;
                            folder["playlists"].removeObject(playlist);
                            goto foundPlaylistItem;
                        }
                for (playlist in self^.playlists)
                    if (playlist["id"] == playlistId) {
                        if (parentFolderId == nothing(NSInteger))
                            return false;
                        playlistItem = playlist;
                        self^.playlists.removeObject(playlist);
                        goto foundPlaylistItem;
                    }
foundPlaylistItem:
                releaseDatabaseLocks();
                moveLibraryPlaylist(self^.library^, playlistId, parentFolderId);
                if (itemIsFolder?(item) and not nil?(playlistItem))
                    item["playlists"].addObject(playlistItem);
                else
                    self^.playlists.addObject(playlistItem);
            } else
                return false;

            outlineView.reloadData();
            if (itemIsFolder?(item))
                outlineView.expandItem(item);

            var playlistRow = outlineView.rowForItem(playlistItem);
            outlineView.selectRowIndexes_byExtendingSelection(
                NSIndexSet.indexSetWithIndex(NSUInteger(playlistRow)),
                false
            );
            if (newPlaylist?)
                outlineView.editColumn_row_withEvent_select(
                    NSInteger(0),
                    NSInteger(playlistRow),
                    nil(NSEvent),
                    true
                );

            return true;
        }],

        [#"outlineView:shouldEditTableColumn:item:", (self, tableView, tableColumn, item) =>
            not item.isKindOfClass(NSString)
        ],

        [#"insertPlaylistWithName:parentItem:", (self, name, parentItem) => {
            var parentId = if (itemIsFolder?(parentItem))
                Maybe(NSInteger(parentItem["id"]))
            else
                nothing(NSInteger);

            releaseDatabaseLocks();
            var id = insertLibraryPlaylist(self^.library^, String(name), parentId);

            var newItem = makeNSMutableDictionary("id", id, "name", name);

            if (itemIsFolder?(parentItem))
                parentItem["playlists"].addObject(newItem);
            else
                self^.playlists.addObject(newItem);

            return newItem;
        }],
        [#"insertPlaylistFolderWithName:", (self, name) => {
            releaseDatabaseLocks();
            var id = insertLibraryPlaylistFolder(self^.library^, String(name));

            var newItem = makeNSMutableDictionary(
                "id", id,
                "name", name,
                "playlists", makeNSMutableArray(),
            );

            self^.folders.addObject(newItem);

            return newItem;
        }],
    ),
);

refreshLibraryDataSource(self: LibraryDataSource) {
    self^.folders.removeAllObjects();
    self^.playlists.removeAllObjects();

    var folderPositions = HashMap[NSUInteger, NSUInteger]();

    for (row in SqliteStatement(self^.library^.db,
        "select playlist_folder_id, name from playlist_folders order by position"
    )) {
        folderPositions[row[0, NSUInteger]] = size(self^.folders);
        self^.folders.addObject(makeNSMutableDictionary(
            "id", row[0, NSInteger],
            "name", row[1],
            "playlists", NSMutableArray.array()
        ));
    }

    for (row in SqliteStatement(self^.library^.db,
        "select playlist_id, name, playlist_folder_id from playlists
            order by playlist_folder_id, position"
    )) {
        var folder = nil(NSMutableArray);

        if (nullColumn?(row, 2)) {
            folder = self^.playlists;
        } else {
            var folderPosition = folderPositions[row[2, NSUInteger]];
            folder = self^.folders[folderPosition]["playlists"];
        }

        folder.addObject(makeNSMutableDictionary(
            "id", row[0, NSInteger],
            "name", row[1]
        ));
    }
}

itemIsPlaylist?(item) = item.isKindOfClass(NSDictionary) and nil?(item["playlists"]);
itemIsFolder?(item) = item.isKindOfClass(NSDictionary) and not nil?(item["playlists"]);

private desc?(ascending?) = if (ascending?) "" else " desc";

sortSQL(sortColumn: String, ascending?: Bool) {
    var desc = desc?(ascending?);
    switch (sortColumn)
    case ("album_name", "album_sort_name", "track_number", "album_compilation_p", "side_number", "sides_count", "track_number", "tracks_count") {
        return str(
            "tracks.album_id is null",
            ", albums.sort_name", desc,
            ", albums.compilation_p", desc,
            ", albums.album_artist_id is null",
            ", album_artists.sort_name", desc, //XXX coalesce with track artist
            ", tracks.side_number", desc,
            ", tracks.track_number", desc,
        );
    } case ("album_artist_name", "album_artist_sort_name") {
        return str(
            "albums.album_artist_id is null",
            ", album_artists.sort_name", desc, //XXX coalesce with track artist
            ", tracks.album_id is null",
            ", albums.sort_name", desc,
            ", albums.compilation_p", desc,
            ", tracks.side_number", desc,
            ", tracks.track_number", desc,
        );
    } case ("track_artist_name", "track_artist_sort_name") {
        return str(
            "tracks.track_artist_id is null",
            ", track_artists.sort_name", desc,
            ", tracks.album_id is null",
            ", albums.sort_name", desc,
            ", albums.compilation_p", desc,
            ", tracks.side_number", desc,
            ", tracks.track_number", desc,
        );
    } case ("genre_name") {
        return "tracks.genre_id is null, genres.name" + desc;
    } case ("composer_name", "composer_sort_name") {
        return "tracks.composer_id is null, composers.sort_name" + desc;
    } case ("grouping_name") {
        return "tracks.grouping_id is null, groupings.name" + desc;
    } case ("duration_time") {
        return "tracks.duration_time" + desc;
    } case ("year") {
        return "tracks.year" + desc;
    } case ("comments") {
        return "tracks.comments is null, tracks.comments" + desc;
    } case ("enabled_p") {
        return "not track_options.enabled_p" + desc;
    } case ("play_count") {
        return "track_options.play_count" + desc;
    } case ("added_date") {
        return "track_options.added_date" + desc;
    } case ("modified_date") {
        return "track_options.modified_date" + desc;
    } case ("played_date") {
        return "track_options.played_date" + desc;

    } else {
        return "tracks.sort_name" + desc;
    }
}

[O | ObjectRef?(O)]
overload sortSQL(sortDescriptors: O) {
    var key = String("name");
    var ascending? = true;
    if (sortDescriptors.count() > 0) {
        var mainDescriptor = sortDescriptors[0];
        key = String(mainDescriptor.key());
        ascending? = mainDescriptor.ascending();
    }
    return sortSQL(key, ascending?);
}

record PlaylistFolderFilter (id: NSInteger);
record PlaylistFilter (id: NSInteger);
record SortedFilter (sort: String);
variant LibraryFilter (PlaylistFolderFilter, PlaylistFilter, SortedFilter);

[S | String?(S) and S != String]
overload SortedFilter(sort: S) = SortedFilter(String(sort));
overload SortedFilter() = SortedFilter(sortSQL(String("name"), true));

[O | ObjectRef?(O)]
overload SortedFilter(sortDescriptors: O) {
    return SortedFilter(sortSQL(sortDescriptors));
}

overload LibraryFilter() = LibraryFilter(SortedFilter());

libraryFilterPlist(view: LibraryFilter) = libraryFilterPlist(*view);
overload libraryFilterPlist(view: PlaylistFolderFilter) = makeNSArray(#"PlaylistFolder", view.id);
overload libraryFilterPlist(view: PlaylistFilter) = makeNSArray(#"Playlist", view.id);
overload libraryFilterPlist(view: SortedFilter) = makeNSArray(#"Library");

[O | ObjectRef?(O)]
overload LibraryFilter(plist: O, defaultFilter) {
    if (plist.isKindOfClass(NSArray)) {
        switch(plist[0])
        case ("PlaylistFolder") {
            if (plist.count() >= 2)
                return LibraryFilter(PlaylistFolderFilter(NSInteger(plist[1])));
            else
                goto defaultPlist;
        } case ("Playlist") {
            if (plist.count() >= 2)
                return LibraryFilter(PlaylistFilter(NSInteger(plist[1])));
            else
                goto defaultPlist;
        } else {
            goto defaultPlist;
        }
    }

defaultPlist:
    return LibraryFilter(defaultFilter);
}

record PlaylistTrack (
    track_view_id: NSInteger,
    track_id: NSInteger,
    filename: String,
    name: String,
    sort_name: Maybe[String],
    album_name: Maybe[String],
    album_sort_name: Maybe[String],
    album_artist_name: Maybe[String],
    album_artist_sort_name: Maybe[String],
    album_compilation_p: Bool,
    track_artist_name: Maybe[String],
    track_artist_sort_name: Maybe[String],
    genre_name: Maybe[String],
    composer_name: Maybe[String],
    composer_sort_name: Maybe[String],
    grouping_name: Maybe[String],
    side_number: Maybe[Int],
    sides_count: Maybe[Int],
    track_number: Maybe[Int],
    tracks_count: Maybe[Int],
    duration_time: NSTimeInterval,
    year: Maybe[String],
    comments: Maybe[String],
    enabled_p: Bool,
    play_count: Maybe[Int],
    added_date: Maybe[Int],
    modified_date: Maybe[Int],
    played_date: Maybe[Int]
);

overload PlaylistTrack() = PlaylistTrack(
    NSInteger(-1),
    NSInteger(0),
    String(),
    String(),
    Maybe[String](),
    Maybe[String](),
    Maybe[String](),
    Maybe[String](),
    Maybe[String](),
    false,
    Maybe[String](),
    Maybe[String](),
    Maybe[String](),
    Maybe[String](),
    Maybe[String](),
    Maybe[String](),
    Maybe[Int](),
    Maybe[Int](),
    Maybe[Int](),
    Maybe[Int](),
    0.0,
    Maybe[String](),
    Maybe[String](),
    true,
    Maybe[Int](),
    Maybe[Int](),
    Maybe[Int](),
    Maybe[Int](),
);

record NoFieldForString (type: StringConstant, string: String);
instance Exception (NoFieldForString);

[R | Record?(R)]
fieldByName(forward r: R, fn, str) {
    ..for (fieldName in ..mapValues(x => x.0, ..RecordFields(R))) {
        if (str == StaticName(fieldName))
            return forward fn(fieldRef(r, fieldName));
    }
    throw NoFieldForString(StaticName(R), String(str));
}

formattedCount(fn, number, count) {
    if (nothing?(count))
        return fn(number);
    else if (just?(number) and just?(count))
        return fn(str(number, " of ", count));
    else
        return fn(nothing(Type(number)));
}

formattedFieldByName(r, fn, str) {
    switch (str)
    case ("track_number") {
        return formattedCount(fn, r.track_number, r.tracks_count);
    } case ("side_number") {
        return formattedCount(fn, r.side_number, r.sides_count);
    } case ("duration_time") {
        return Id(timeFormat(r.duration_time));
    } case ("added_date") {
        return Id(dateFormat(*r.added_date));
    } case ("modified_date") {
        return Id(dateFormat(*r.modified_date));
    } case ("played_date") {
        return Id(dateFormat(*r.played_date));
    } else {
        return fieldByName(r, fn, str);
    }
}

overload selector(static #"initWithLibrary:filter:sortDescriptors:") = Void, Pointer[Library], Pointer[LibraryFilter], NSArray;
overload selector(static #"setLibraryFilter:tableView:") = Void, Pointer[LibraryFilter], NSTableView;
overload selector(static #"libraryFilter") = Pointer[LibraryFilter];
overload selector(static #"setSearchString:") = Void, NSString;
overload selector(static #"searchString") = NSString;
overload selector(static #"playlistStatus") = PlaylistStatus;
overload selector(static #"releaseDatabaseLocks") = Void;

maybeObject(x) = Id(x);
overload maybeObject(x: Nothing) = nil();
[T] overload maybeObject(x: Maybe[T]) = maybeObject(*x);

alias TrackIdsPboardType
    = NSString(#"com.duriansoftware.Vinyl.pasteboard.track_ids");
alias TrackPositionsPboardType
    = NSString(#"com.duriansoftware.Vinyl.pasteboard.track_positions");
alias PlaylistIdsPboardType
    = NSString(#"com.duriansoftware.Vinyl.pasteboard.playlist_ids");

alias PlaylistDidChangeNotification = NSString(#"VinylPlaylistDidChangeNotification");
alias PlaylistIDKey = NSString(#"VinylPlaylistID");
alias PlaylistNewTrackViewId = NSString(#"VinylPlaylistNewTrackViewId");

record PlaylistDataSource = newClass(NSObject,
    InstanceVars(
        library: Pointer[Library],
        libraryFilter: LibraryFilter,
        searchString: Retained[NSString],
        playingTrackViewId: Maybe[NSInteger],
        playingMode: PlaylistMode,
        tracks: SqliteLazySequence(PlaylistTrack),
        librarySort: Retained[NSArray],
    ),
    ClassMethods(),
    InstanceMethods(
        [#"initWithLibrary:filter:sortDescriptors:", (self, library, filter, sortDescriptors) =>
            initObjectWith(self, #"init", self => {
                self^.library = library;
                self^.libraryFilter <-- filter^;
                self^.playingTrackViewId <-- nothing(NSInteger);
                self^.playingMode <-- Paused;
                self^.tracks <-- libraryFilterStatementSequence(
                    self^.library^.db, 
                    String(), // search string
                    self^.libraryFilter
                );
                self^.librarySort = sortDescriptors;
                refreshPlaylistDataSource(self);
                return self;
            })
        ],
        DeallocInstanceMethod(),
        [#"numberOfRowsInTableView:", (self, tableView) => NSInteger(size(self^.tracks))],
        [#"tableView:objectValueForTableColumn:row:", (self, tableView, tableColumn, rowIndex) =>
            if (tableColumn.identifier() == "playing_p")
                maybe(self^.playingTrackViewId,
                    trackViewId =>
                        if (self^.tracks[rowIndex].track_view_id == trackViewId)
                            (if (self^.playingMode == Paused) Id(#"||") else Id(#">"))
                        else
                            nil(),
                    () => nil(),
                )
            else
                formattedFieldByName(self^.tracks[rowIndex], maybeObject, tableColumn.identifier())
        ],
        [#"tableView:deleteRowsWithIndexes:", (self, tableView, rowIndexes) => {
            matchByType(self^.libraryFilter,
                PlaylistFilter, playlist => {
                    var rows = indexSetIndices(rowIndexes);

                    releaseDatabaseLocks();
                    deleteLibraryPlaylistPositions(self^.library^, playlist.id, rows);
                    refreshPlaylistDataSource(self);
                    tableView.reloadData();
                    tableView.selectRowIndexes_byExtendingSelection(
                        NSIndexSet.indexSet(),
                        false
                    );
                    NSNotificationCenter.defaultCenter().postNotificationName_object_userInfo(
                        PlaylistDidChangeNotification,
                        self,
                        makeNSDictionary(PlaylistIDKey, playlist.id),
                    );
                },
                MatchDefault, _ => {}
            );
        }],
        [#"tableView:writeRowsWithIndexes:toPasteboard:", (self, tableView, rowIndexes, pasteboard) => {
            var filenames = NSMutableArray.array();
            var trackIds = NSMutableArray.array();
            var trackPositions = NSMutableArray.array();

            var rows = indexSetIndices(rowIndexes);

            for (row in rows) {
                filenames.addObject(self^.tracks[row].filename);
                trackIds.addObject(self^.tracks[row].track_id);
                trackPositions.addObject(row);
            }

            var localMask = matchByType(self^.libraryFilter,
                PlaylistFilter,       v => bitor(NSDragOperationCopy, NSDragOperationMove, NSDragOperationDelete),
                PlaylistFolderFilter, v => bitor(NSDragOperationCopy, NSDragOperationDelete),
                SortedFilter,         v => bitor(NSDragOperationCopy, NSDragOperationDelete),
            );

            tableView.setDraggingSourceOperationMask_forLocal(
                NSUInteger(localMask),
                true
            );
            tableView.setDraggingSourceOperationMask_forLocal(
                NSUInteger(bitor(NSDragOperationCopy, NSDragOperationDelete)),
                false
            );

            pasteboard.declareTypes_owner(
                makeNSArray(NSFilenamesPboardType, TrackIdsPboardType, TrackPositionsPboardType),
                self
            );
            pasteboard.setPropertyList_forType(filenames, NSFilenamesPboardType);
            pasteboard.setPropertyList_forType(trackIds, TrackIdsPboardType);
            pasteboard.setPropertyList_forType(trackPositions, TrackPositionsPboardType);

            return true;
        }],

        [#"tableView:validateDrop:proposedRow:proposedDropOperation:", (self, tableView, info, row, operation) => {
            var allowDrop = matchByType(self^.libraryFilter,
                PlaylistFilter, v => true,
                PlaylistFolderFilter, v => false,
                SortedFilter, v => false,
            );
            if (not allowDrop) return NSDragOperation(NSDragOperationNone);

            var pasteboard = info.draggingPasteboard();
            var pasteboardType = pasteboard.availableTypeFromArray(makeNSArray(TrackPositionsPboardType));
            if (nil?(pasteboardType))
                return NSDragOperation(NSDragOperationNone);

            if (row == -1)
                tableView.setDropRow_dropOperation(
                    tableView.numberOfRows(),
                    NSTableViewDropOperation(NSTableViewDropAbove)
                );
            else
                tableView.setDropRow_dropOperation(
                    row,
                    NSTableViewDropOperation(NSTableViewDropAbove)
                );
            return NSDragOperation(NSDragOperationMove);
        }],
        [#"tableView:acceptDrop:row:dropOperation:", (self, tableView, info, row, operation) => {
            var ok?, playlistId = ..matchByType(self^.libraryFilter,
                PlaylistFilter,       v => (true, NSInteger(v.id)),
                PlaylistFolderFilter, v => (false, NSInteger(-1)),
                SortedFilter,         v => (false, NSInteger(-1)),
            );
            if (not ok?)
                return false;

            var pasteboard = info.draggingPasteboard();
            var pasteboardType = pasteboard.availableTypeFromArray(makeNSArray(TrackPositionsPboardType));
            if (nil?(pasteboardType))
                return false;

            var trackPositions = mapped(NSInteger, pasteboard.propertyListForType(pasteboardType));
            releaseDatabaseLocks();
            var newPosition = moveLibraryPlaylistTracks(self^.library^, playlistId, trackPositions, row);
            refreshPlaylistDataSource(self);
            tableView.reloadData();

            tableView.selectRowIndexes_byExtendingSelection(
                NSIndexSet.indexSetWithIndexesInRange(
                    NSMakeRange(NSUInteger(newPosition), NSUInteger(size(trackPositions)))
                ),
                false
            );

            NSNotificationCenter.defaultCenter().postNotificationName_object_userInfo(
                PlaylistDidChangeNotification,
                self,
                makeNSDictionary(PlaylistIDKey, playlistId),
            );

            return true;
        }],

        [#"tableView:sortDescriptorsDidChange:", (self, tableView, oldDescriptors) => {
            matchByType(self^.libraryFilter,
                SortedFilter,   v => {
                    self^.librarySort = tableView.sortDescriptors();
                    self^.libraryFilter = LibraryFilter(SortedFilter(self^.librarySort));
                    refreshPlaylistDataSource(self);
                    tableView.reloadData();
                },
                PlaylistFilter, v => {
                    if (tableView.sortDescriptors().count() > 0) {
                        releaseDatabaseLocks();
                        self^.playingTrackViewId = sortLibraryPlaylist(
                            self^.library^,
                            NSInteger(v.id),
                            self^.playingTrackViewId,
                            sortSQL(tableView.sortDescriptors())
                        );
                        refreshPlaylistDataSource(self);
                        tableView.reloadData();
                        var notificationInfo = maybe(self^.playingTrackViewId,
                            trackViewId => makeNSDictionary(
                                PlaylistIDKey, v.id,
                                PlaylistNewTrackViewId, trackViewId,
                            ),
                            () => makeNSDictionary(
                                PlaylistIDKey, v.id,
                            )
                        );
                        NSNotificationCenter.defaultCenter().postNotificationName_object_userInfo(
                            PlaylistDidChangeNotification,
                            self,
                            notificationInfo
                        );
                    }
                },
                PlaylistFolderFilter, v => {
                    if (tableView.sortDescriptors().count() > 0) {
                        tableView.setSortDescriptors(NSArray.array());
                    }
                }
            );
        }],

        [#"libraryFilter", self => &self^.libraryFilter],
        [#"setLibraryFilter:tableView:", (self, filter, tableView) => {
            self^.libraryFilter = filter^;
            matchByType(self^.libraryFilter,
                SortedFilter,  v => { tableView.setSortDescriptors(self^.librarySort); },
                MatchDefault, v => { tableView.setSortDescriptors(NSArray.array()); }
            );
            // XXX preserve search for each filter
            self^.searchString = Retained(nil(NSString));

            refreshPlaylistDataSource(self);
        }],
        [#"searchString", self => self^.searchString],
        [#"setSearchString:", (self, s) => {
            self^.searchString
                = if (s.length() == 0) Retained(nil(NSString)) else Retained(s.copy());
            refreshPlaylistDataSource(self);
        }],

        [#"playlistStatus", self => libraryFilterStatus(
            self^.library^.db,
            if (nil?(self^.searchString)) String() else String(self^.searchString),
            self^.libraryFilter,
        )],

        [#"releaseDatabaseLocks", self => {
            forceAllRows(self^.tracks);
        }],
    ),
);

private basePlaylistSelectClause(filter: SortedFilter) = "
    select
        tracks.track_id as track_view_id,
        tracks.track_id as track_id,
        tracks.filename as filename,
        tracks.display_name as name,
        tracks.sort_name as sort_name,
        albums.display_name as album_name,
        albums.sort_name as album_sort_name,
        album_artists.display_name as album_artist_name,
        album_artists.sort_name as album_artist_sort_name,
        albums.compilation_p as album_compilation_p,
        coalesce(track_artists.display_name, album_artists.display_name) as track_artist_name,
        coalesce(track_artists.sort_name,    album_artists.sort_name)    as track_artist_sort_name,
        genres.name as genre_name,
        composers.display_name as composer_name,
        composers.sort_name as composer_sort_name,
        groupings.name as grouping_name,
        tracks.side_number as side_number,
        albums.sides_count as sides_count,
        tracks.track_number as track_number,
        album_sides.tracks_count as tracks_count,
        tracks.duration_time as duration_time,
        tracks.year as year,
        tracks.comments as comments,
        coalesce(track_options.enabled_p, 1) as enabled_p,
        track_options.play_count as play_count,
        track_options.added_date as added_date,
        track_options.modified_date as modified_date,
        track_options.played_date as played_date
    ";

overload basePlaylistSelectClause(filter: PlaylistFilter) = "
    select
        playlist_tracks.position as track_view_id,
        tracks.track_id as track_id,
        tracks.filename as filename,
        tracks.display_name as name,
        tracks.sort_name as sort_name,
        albums.display_name as album_name,
        albums.sort_name as album_sort_name,
        album_artists.display_name as album_artist_name,
        album_artists.sort_name as album_artist_sort_name,
        albums.compilation_p as album_compilation_p,
        coalesce(track_artists.display_name, album_artists.display_name) as track_artist_name,
        coalesce(track_artists.sort_name,    album_artists.sort_name)    as track_artist_sort_name,
        genres.name as genre_name,
        composers.display_name as composer_name,
        composers.sort_name as composer_sort_name,
        groupings.name as grouping_name,
        tracks.side_number as side_number,
        albums.sides_count as sides_count,
        tracks.track_number as track_number,
        album_sides.tracks_count as tracks_count,
        tracks.duration_time as duration_time,
        tracks.year as year,
        tracks.comments as comments,
        coalesce(track_options.enabled_p, 1) as enabled_p,
        track_options.play_count as play_count,
        track_options.added_date as added_date,
        track_options.modified_date as modified_date,
        track_options.played_date as played_date
    ";

// XXX hack: assumes fewer than 100,000 tracks per playlist
overload basePlaylistSelectClause(view: PlaylistFolderFilter) = "
    select
        100000 * playlists.position + playlist_tracks.position as track_view_id,
        tracks.track_id as track_id,
        tracks.filename as filename,
        tracks.display_name as name,
        tracks.sort_name as sort_name,
        albums.display_name as album_name,
        albums.sort_name as album_sort_name,
        album_artists.display_name as album_artist_name,
        album_artists.sort_name as album_artist_sort_name,
        albums.compilation_p as album_compilation_p,
        coalesce(track_artists.display_name, album_artists.display_name) as track_artist_name,
        coalesce(track_artists.sort_name,    album_artists.sort_name)    as track_artist_sort_name,
        genres.name as genre_name,
        composers.display_name as composer_name,
        composers.sort_name as composer_sort_name,
        groupings.name as grouping_name,
        tracks.side_number as side_number,
        albums.sides_count as sides_count,
        tracks.track_number as track_number,
        album_sides.tracks_count as tracks_count,
        tracks.duration_time as duration_time,
        tracks.year as year,
        tracks.comments as comments,
        coalesce(track_options.enabled_p, 1) as enabled_p,
        track_options.play_count as play_count,
        track_options.added_date as added_date,
        track_options.modified_date as modified_date,
        track_options.played_date as played_date
    ";

private alias playlistFromClauseLeftJoins = "
        left join albums on tracks.album_id = albums.album_id
        left join album_sides
            on tracks.album_id = album_sides.album_id
            and tracks.side_number = album_sides.side_number
        left join artists as album_artists on albums.album_artist_id = album_artists.artist_id
        left join artists as track_artists on tracks.track_artist_id = track_artists.artist_id
        left join genres on tracks.genre_id = genres.genre_id
        left join composers on tracks.composer_id = composers.composer_id
        left join groupings on tracks.grouping_id = groupings.grouping_id
        left join track_options on tracks.track_id = track_options.track_id
    ";

private alias basePlaylistFromClause = "
        tracks
    ";

private alias searchPlaylistFromClause = "
        tracks
        inner join tracks_fts
            on tracks_fts.docid = tracks.track_id
    ";

private  filterFromClauseInnerJoins(filter: SortedFilter) = "";
overload filterFromClauseInnerJoins(filter: PlaylistFilter) = "
        inner join playlist_tracks
            on tracks.track_id = playlist_tracks.track_id
    ";
overload filterFromClauseInnerJoins(filter: PlaylistFolderFilter) = "
        inner join playlist_tracks
            on tracks.track_id = playlist_tracks.track_id
        inner join playlists
            on playlist_tracks.playlist_id = playlists.playlist_id
    ";

private alias sortWhereClause = "
        tracks_fts.tracks_fts match :search
    ";

private  filterWhereClause(filter: SortedFilter) = "1";
overload filterWhereClause(filter: PlaylistFilter) = "
        playlist_tracks.playlist_id = :playlist_id
    ";
overload filterWhereClause(filter: PlaylistFolderFilter) = "
        playlists.playlist_folder_id = :playlist_folder_id
    ";

private  filterOrderByClause(filter: SortedFilter) = filter.sort;
overload filterOrderByClause(filter: PlaylistFilter) = String("playlist_tracks.position");
overload filterOrderByClause(filter: PlaylistFolderFilter)
    = String("playlists.position, playlist_tracks.position");

private  bindFilterParameters(stmt: SqliteStatement, filter: SortedFilter) { }
overload bindFilterParameters(stmt: SqliteStatement, filter: PlaylistFilter) {
    bindStatement(stmt, ":playlist_id", filter.id);
}
overload bindFilterParameters(stmt: SqliteStatement, filter: PlaylistFolderFilter) {
    bindStatement(stmt, ":playlist_folder_id", filter.id);
}

libraryFilterStatementFromClause(db: SqliteDB, search: String, filter: LibraryFilter) {
    var searching? = not empty?(search);
    var stmtString = String(" from (");
    if (searching?)
        stmtString += searchPlaylistFromClause;
    else
        stmtString += basePlaylistFromClause;
    stmtString += filterFromClauseInnerJoins(*filter);
    stmtString += ") ";
    stmtString += playlistFromClauseLeftJoins;
    stmtString += " where ";
    if (searching?)
        stmtString += sortWhereClause + " and ";
    stmtString += filterWhereClause(*filter);
    return stmtString;
}

libraryFilterSize(db: SqliteDB, search: String, filter: LibraryFilter) {
    var searching? = not empty?(search);
    var stmtString = "select count(1) "
        + libraryFilterStatementFromClause(db, search, filter);

    var stmt = SqliteStatement(db, stmtString);
    if (searching?)
        bindStatement(stmt, ":search", search);
    bindFilterParameters(stmt, *filter);
    return statementValue(SizeT, stmt);
}

record PlaylistStatus (size: SizeT, duration: Double); 

libraryFilterStatus(db: SqliteDB, search: String, filter: LibraryFilter) {
    var searching? = not empty?(search);
    var stmtString = "select count(1) as size, sum(duration_time) as duration "
        + libraryFilterStatementFromClause(db, search, filter);

    var stmt = SqliteStatement(db, stmtString);
    if (searching?)
        bindStatement(stmt, ":search", search);
    bindFilterParameters(stmt, *filter);
    return rowRecord(statementSingleRow(stmt), PlaylistStatus);
}

libraryFilterStatement(db: SqliteDB, search: String, filter: LibraryFilter) {
    var searching? = not empty?(search);
    var stmtString = basePlaylistSelectClause(*filter)
        + libraryFilterStatementFromClause(db, search, filter);
    stmtString += " order by ";
    stmtString += filterOrderByClause(*filter);

    var stmt = SqliteStatement(db, stmtString);
    if (searching?)
        bindStatement(stmt, ":search", search);
    bindFilterParameters(stmt, *filter);
    return move(stmt);
}

libraryFilterStatementSequence(db: SqliteDB, search: String, filter: LibraryFilter) {
    var size = libraryFilterSize(db, search, filter);
    return sqliteLazySequence(
        PlaylistTrack,
        libraryFilterStatement(db, search, filter), 
        size
    );
}

refreshPlaylistDataSource(self: PlaylistDataSource) {
    var search = if (nil?(self^.searchString))
            String()
        else
            String(self^.searchString) + "*";

    self^.tracks = libraryFilterStatementSequence(self^.library^.db, search, self^.libraryFilter);
}

// XXX this and its dependencies should be in Vinyl.library
sortLibraryPlaylist(
    library: Library,
    playlistId: NSInteger,
    playingTrackViewId: Maybe[NSInteger],
    sortSQL
) {
    return withTransaction(library.db, () -> {
        var playlistFilter = LibraryFilter(PlaylistFilter(playlistId));
        var stmtString = "create temporary table new_playlist_track_positions as select
                tracks.track_id,
                playlist_tracks.position = :playing_track_view_id as playing_p
            " + libraryFilterStatementFromClause(library.db, String(), playlistFilter);
        stmtString += " order by " + sortSQL;

        var stmt = SqliteStatement(library.db, stmtString);
        bindFilterParameters(stmt, *playlistFilter);
        bindStatement(stmt, ":playing_track_view_id", playingTrackViewId);

        runStatement(stmt);

        runStatement(library.db, "delete from playlist_tracks where playlist_id = ?", playlistId);
        runStatement(library.db,
            "insert into playlist_tracks (playlist_id, track_id, position) select
                ? as playlist_id,
                nptp.track_id as track_id,
                nptp.rowid - 1 as position
            from
                new_playlist_track_positions nptp
            ", playlistId
        );

        var newPlayingTrackViewId = maybeStatementValue(NSInteger, library.db, "select rowid - 1 from new_playlist_track_positions where playing_p");

        runStatement(library.db, "drop table new_playlist_track_positions");

        return newPlayingTrackViewId;
    });
}
